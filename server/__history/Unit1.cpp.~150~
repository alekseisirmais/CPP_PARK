#include <vcl.h>
#include <SetupAPI.h>
#include <cfgmgr32.h>
#include <initguid.h>
#include <winioctl.h>
#include <windows.h>
#include <vector>
#include <string>
static GUID GUID_DEVINTERFACE_USB_DEVICE ={ 0xA5DCBF10L, 0x6530, 0x11D2, { 0x90, 0x1F, 0x00, 0xC0, 0x4F, 0xB9, 0x51, 0xED } };


#pragma hdrstop

#include "Unit1.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm1 *Form1;
bool canCloseFlag;
//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
	: TForm(Owner)
{
}

//---------------------------------------------------------------------------

void __fastcall TForm1::FormCreate(TObject *Sender)
{
	Memo1->Lines->Clear();
	canCloseFlag = true;
	ServerSocket1->Port = 9001;
	ServerSocket1->Active = false;
	Memo1->Lines->Add("Server port: 9001; Server don't run");
	Button1->Caption = "Start";
}
//---------------------------------------------------------------------------

void __fastcall TForm1::MyFormCloseEvent(TObject *Sender, bool &CanClose)
{
	if (canCloseFlag) {
		CanClose = true;
	} else {
		CanClose = false;
	}
}
//---------------------------------------------------------------------------

void __fastcall TForm1::MyOnClientConnectEvent(TObject *Sender, TCustomWinSocket *Socket)

{
	Memo1->Lines->Add("Client connected");
}
//---------------------------------------------------------------------------


void __fastcall TForm1::Button1Click(TObject *Sender)
{
	if (ServerSocket1->Active) {
		ServerSocket1->Active = false;
		Memo1->Lines->Add("Server paused");
		Button1->Caption = "Start";
	}
	else {
		ServerSocket1->Active = true;
		Memo1->Lines->Add("Server activated");
		Button1->Caption = "Stop";
	}
}
//---------------------------------------------------------------------------

void __fastcall TForm1::Button2Click(TObject *Sender)
{
	Memo1->Lines->Clear();
}
//---------------------------------------------------------------------------


void __fastcall TForm1::Button3Click(TObject *Sender)
{
	if (canCloseFlag) {
		Memo1->Lines->Add("You can't close the app");
		canCloseFlag = false;
	} else {
		Memo1->Lines->Add("You can close the app");
		canCloseFlag = true;
	}
}
//---------------------------------------------------------------------------
struct USB {
	int vid;
	int pid;
	USB(int _vid, int _pid) {
		vid = _vid;
		pid = _pid;
	}
	const bool operator != (const USB &_usb) {
		if ((vid != _usb.vid) || (pid != _usb.pid)) {
			return true;
		}
		return false;
	}
	const bool operator == (const USB &_usb) {
		if ((vid == _usb.vid) && (pid == _usb.pid)) {
			return true;
		}
		return false;
	}
};

bool GetUSBVidAndPid(TCHAR DeviceInstance[], int &vid, int &pid) {
	try {
   		vid = 0;
		pid = 0;
		// USB\VID_058F&PID_6387\DD1BA51B
		int i = 0;
		while ((DeviceInstance[i] < '0') || (DeviceInstance[i] > '9')) {
			i++;
		}

		while ((DeviceInstance[i] >= '0') && (DeviceInstance[i] <= '9')) {
			vid = vid * 10 + DeviceInstance[i] - '0';
			i++;
		}

		while ((DeviceInstance[i] < '0') || (DeviceInstance[i] > '9')) {
			i++;
		}

		while ((DeviceInstance[i] >= '0') && (DeviceInstance[i] <= '9')) {
			pid = pid * 10 + DeviceInstance[i] - '0';
			i++;
		}
		return true;
	} catch (int e) {
		return false;
	}
	return false;
}


void __fastcall TForm1::Button5Click(TObject *Sender)
{
	DWORD error,
		dwPropertyRegDataType,
		dwSize;
	CONST GUID *pClassGuid = &GUID_DEVINTERFACE_USB_DEVICE;
	TCHAR szDeviceInstanceID [MAX_DEVICE_ID_LEN];
	PCWSTR enumerator = TEXT("USB");
	TCHAR szDesc[1024],
		szHardwareIDs[4096];
	LPTSTR pszToken,
		pszNextToken;
	TCHAR szVid[MAX_DEVICE_ID_LEN],
		szPid[MAX_DEVICE_ID_LEN],
			szMi[MAX_DEVICE_ID_LEN];
	rsize_t *strmax = NULL;
	const static LPCTSTR arPrefix[3] = {TEXT("VID_"), TEXT("PID_"), TEXT("MI_")};

	SP_DEVINFO_DATA deviceInfoData;
	ZeroMemory(&deviceInfoData, sizeof(SP_DEVINFO_DATA));
	deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

	HDEVINFO deviceInfoSet = SetupDiGetClassDevs(
		pClassGuid,
		enumerator,
		NULL,
		// DIGCF_PRESENT Возвращайте только устройства, которые в
		// настоящее время присутствуют в системе.
		DIGCF_ALLCLASSES | DIGCF_PRESENT
	);
	if (deviceInfoSet == INVALID_HANDLE_VALUE) {
		error = GetLastError();
		Memo1->Lines->Add("INVALID_HANDLE_VALUE" + IntToStr((int)error));
		return;
	}

	for (DWORD i = 0; ; i++) {
		deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
		if (!SetupDiEnumDeviceInfo(deviceInfoSet, i, &deviceInfoData)) {
			break;
		}

		CONFIGRET status = CM_Get_Device_ID(deviceInfoData.DevInst, szDeviceInstanceID , MAX_PATH, 0);
		if (status != CR_SUCCESS) {
			continue;
		}


		if (SetupDiGetDeviceRegistryProperty(deviceInfoSet, &deviceInfoData, SPDRP_DEVICEDESC,
											  &dwPropertyRegDataType, (BYTE*)szDesc,
											  sizeof(szDesc),   // The size, in bytes
											  &dwSize)) {
		}

		if (WideCharToString(szDesc) != "USB Mass Storage Device") {
			continue;
		}

		// Display device instance ID
		Memo1->Lines->Add(szDeviceInstanceID);
		Memo1->Lines->Add(WideCharToString(szDesc));



		/*
		if (SetupDiGetDeviceRegistryProperty(deviceInfoSet, &deviceInfoData, SPDRP_HARDWAREID,
											  &dwPropertyRegDataType, (BYTE*)szHardwareIDs,
											  sizeof(szHardwareIDs),    // The size, in bytes
											  &dwSize)) {
			LPCTSTR pszId;
			Memo1->Lines->Add("    Hardware IDs:\n");
			for (pszId=szHardwareIDs;
					*pszId != TEXT('\0') && pszId + dwSize/sizeof(TCHAR) <= szHardwareIDs + ARRAYSIZE(szHardwareIDs);
					pszId += lstrlen(pszId)+1) {
				Memo1->Lines->Add(pszId);
			}
		}
		*/

		int vid = 0;
		int pid = 0;
		GetUSBVidAndPid(szDeviceInstanceID, vid, pid);
		Memo1->Lines->Add("VID: " + IntToStr(vid));
		Memo1->Lines->Add("PID: " + IntToStr(pid));
		Memo1->Lines->Add("");
	}
	SetupDiDestroyDeviceInfoList(deviceInfoSet);
}

//---------------------------------------------------------------------------

void __fastcall TForm1::Button4Click(TObject *Sender)
{
	DWORD error,
		dwPropertyRegDataType,
		dwSize;
	CONST GUID *pClassGuid = &GUID_DEVINTERFACE_USB_DEVICE;
	TCHAR szDeviceInstanceID [MAX_DEVICE_ID_LEN];
	PCWSTR enumerator = TEXT("USB");
	TCHAR szDesc[1024],
		szHardwareIDs[4096];
	LPTSTR pszToken,
		pszNextToken;
	TCHAR szVid[MAX_DEVICE_ID_LEN],
		szPid[MAX_DEVICE_ID_LEN],
			szMi[MAX_DEVICE_ID_LEN];
	rsize_t *strmax = NULL;
	const static LPCTSTR arPrefix[3] = {TEXT("VID_"), TEXT("PID_"), TEXT("MI_")};

	SP_DEVINFO_DATA deviceInfoData;
	ZeroMemory(&deviceInfoData, sizeof(SP_DEVINFO_DATA));
	deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

	HDEVINFO deviceInfoSet = SetupDiGetClassDevs(
		pClassGuid,
		enumerator,
		NULL,
		// DIGCF_PRESENT Возвращайте только устройства, которые в
		// настоящее время присутствуют в системе.
		DIGCF_ALLCLASSES | DIGCF_PRESENT
	);
	if (deviceInfoSet == INVALID_HANDLE_VALUE) {
		error = GetLastError();
		Memo1->Lines->Add("INVALID_HANDLE_VALUE" + IntToStr((int)error));
		return;
	}

	for (DWORD i = 0; ; i++) {
		deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
		if (!SetupDiEnumDeviceInfo(deviceInfoSet, i, &deviceInfoData)) {
			break;
		}

		CONFIGRET status = CM_Get_Device_ID(deviceInfoData.DevInst, szDeviceInstanceID , MAX_PATH, 0);
		if (status != CR_SUCCESS) {
			continue;
		}


		if (SetupDiGetDeviceRegistryProperty(deviceInfoSet, &deviceInfoData, SPDRP_DEVICEDESC,
											  &dwPropertyRegDataType, (BYTE*)szDesc,
											  sizeof(szDesc),   // The size, in bytes
											  &dwSize)) {

		}

		if (WideCharToString(szDesc) != "USB Mass Storage Device") {
			continue;
		}

		int vid = 0;
		int pid = 0;

		GetUSBVidAndPid(szDeviceInstanceID, vid, pid);
		if (USB(vid, pid) != USB(58, 6387)) {
			continue;
		}


		DEVINST DevInstParent = deviceInfoData.DevInst;
		WCHAR VetoNameW[MAX_PATH];
		PNP_VETO_TYPE VetoType = PNP_VetoTypeUnknown;
		for ( long tries=1; tries <= 10; tries++ ) {
			VetoNameW[0] = 0;
			CONFIGRET res = CM_Request_Device_EjectW(DevInstParent,
				&VetoType, VetoNameW, MAX_PATH, 0);

			bool bSuccess = ( res==CR_SUCCESS &&
				VetoType==PNP_VetoTypeUnknown );
			if ( bSuccess )  {
				Memo1->Lines->Add("USB(" + IntToStr(vid) + ", " + IntToStr(pid) + ") ejected");
				break;
			}
			Sleep(5);
		}
	}
	SetupDiDestroyDeviceInfoList(deviceInfoSet);
}

//---------------------------------------------------------------------------
std::vector<USB> GetUSBListFromDB(AnsiString &file) {
	TStringList *list1 = new TStringList;
	list1->LoadFromFile(file);
	std::vector<USB> res;

	for (int i = 0; i < list1->Count; i++) {
		AnsiString str = list1[0][i];
		int StrLenInt = str.Length();
		int SpacePlaceInt = str.Pos(" ");
		int pid = StrToInt(str.SubString(1, SpacePlaceInt - 1));
		//AnsiStrings always start with 1 and not 0
		int vid = StrToInt(str.SubString(SpacePlaceInt + 1, StrLenInt));
		USB usb(pid, vid);
		res.push_back(usb);
	}



	return res;
}


void AddUsbToDatabase(USB *usb, AnsiString &file) {
	TStringList *list1 = new TStringList;
	AnsiString USBstring = IntToStr(usb->pid) + " " + IntToStr(usb->vid);
	list1->Add(USBstring);
	if (!FileExists(file)) {
		list1->SaveToFile(file);
	}

	TStringList *list2 = new TStringList;
	list2->LoadFromFile(file);
	list2->Text = list2->Text + list1->Text;
	list2->SaveToFile(file);
	delete list1;
	delete list2;
}

